// @/app/@right/(_server)/api/app-config-update/persist/route.ts
// Comments in English: Persist AppConfig to filesystem or GitHub

import { NextRequest, NextResponse } from "next/server";
import fs from "fs";
import path from "path";
import { AppConfigErrorCode, AppConfigOperationStatus, AppConfigPersistResponse, AppConfigUpdateData } from "@/app/@right/(_service)/(_components)/nav-bar/admin-flow/editable-wide-menu/components/page-actions-dropdown/components/home-actions-menu/(_types)/api-response-types";
import { requirePrivilegedUser } from "@/app/@right/(_service)/(_utils)/auth-helpers";

const DEFAULT_CONFIG_PATH = "config/appConfig.ts";

function getFilePaths() {
  const relativePath = DEFAULT_CONFIG_PATH;
  const localPath = path.resolve(process.cwd(), relativePath);

  return {
    localPath,
    relativePath,
  };
}

const { localPath: CONFIG_PATH, relativePath: GITHUB_RELATIVE_PATH } =
  getFilePaths();

function isProduction() {
  return process.env.NODE_ENV === "production";
}

function validateGitHubConfig(): { isValid: boolean; missingVars: string[] } {
  const requiredVars = [
    { key: "GITHUB_TOKEN", value: process.env.GITHUB_TOKEN },
    { key: "GITHUB_REPO", value: process.env.GITHUB_REPO },
  ];

  const missingVars = requiredVars
    .filter(({ value }) => !value)
    .map(({ key }) => key);

  return {
    isValid: missingVars.length === 0,
    missingVars,
  };
}

async function getCurrentFileFromGitHub(): Promise<{
  content: string;
  sha: string;
} | null> {
  try {
    const { GITHUB_TOKEN, GITHUB_REPO } = process.env;

    const response = await fetch(
      `https://api.github.com/repos/${GITHUB_REPO}/contents/${GITHUB_RELATIVE_PATH}`,
      {
        headers: {
          Authorization: `Bearer ${GITHUB_TOKEN}`,
          Accept: "application/vnd.github.v3+json",
          "User-Agent": "NextJS-App",
        },
      }
    );

    if (response.status === 404) {
      return null;
    }

    if (!response.ok) {
      throw new Error(
        `GitHub API error: ${response.status} ${response.statusText}`
      );
    }

    const data = await response.json();

    if (data.type !== "file") {
      throw new Error("GitHub path is not a file");
    }

    const content = Buffer.from(data.content, "base64").toString("utf-8");

    return {
      content,
      sha: data.sha,
    };
  } catch (error) {
    throw error;
  }
}

/**
 * Generate complete AppConfig.ts file content
 * Full template string replacement approach with modern images structure
 */
function generateAppConfigFile(config: AppConfigUpdateData): string {
  const timestamp = new Date().toISOString();
  
  return `// @/config/appConfig.ts
// Comments in English: Single source of truth for SEO/PWA. Everything reads from here.

const site_url = "${config.siteUrl}";

export const appConfig: AppConfig = {
  name: "${config.name}",
  short_name: "${config.short_name}",
  description: "${config.description}",
  url: site_url,

  manifest: "/manifest.webmanifest",

  lang: "${config.lang}",
  mailSupport: "support@aifa.dev",
  chatBrand: "${config.chatBrand}",

  images: {
    "ogImage": {
      path: "/app-config-images/og-image.jpg",
      format: "jpeg",
      uploadedAt: "${timestamp}",
    },
    "loading-dark": {
      path: "/app-config-images/loading-dark.svg",
      format: "svg",
      uploadedAt: "${timestamp}",
    },
    "loading-light": {
      path: "/app-config-images/loading-light.svg",
      format: "svg",
      uploadedAt: "${timestamp}",
    },
    "notFound-dark": {
      path: "/app-config-images/not-found-dark.svg",
      format: "svg",
      uploadedAt: "${timestamp}",
    },
    "notFound-light": {
      path: "/app-config-images/not-found-light.svg",
      format: "svg",
      uploadedAt: "${timestamp}",
    },
    "error500-dark": {
      path: "/app-config-images/error500-dark.svg",
      format: "svg",
      uploadedAt: "${timestamp}",
    },
    "error500-light": {
      path: "/app-config-images/error500-light.svg",
      format: "svg",
      uploadedAt: "${timestamp}",
    },
    "homePage-dark": {
      path: "/app-config-images/homepage-dark.png",
      format: "png",
      uploadedAt: "${timestamp}",
    },
    "homePage-light": {
      path: "/app-config-images/homepage-light.png",
      format: "png",
      uploadedAt: "${timestamp}",
    },
    "chatbot-dark": {
      path: "/app-config-images/chatbot-dark.png",
      format: "png",
      uploadedAt: "${timestamp}",
    },
    "chatbot-light": {
      path: "/app-config-images/chatbot-light.png",
      format: "png",
      uploadedAt: "${timestamp}",
    },
  },

  // Logo field - handled by separate upload flow with icon generation
  logo: "${config.logo}",

  // Icons set for Metadata API and PWA (generated by logo upload)
  icons: {
    icon32: "/app-config-images/icons/icon-32.png",
    icon48: "/app-config-images/icons/icon-48.png",
    icon192: "/app-config-images/icons/icon-192.png",
    icon512: "/app-config-images/icons/icon-512.png",
    appleTouch: "/app-config-images/icons/apple-touch-icon.png",
  },

  // PWA defaults
  pwa: {
    themeColor: "#ffffff",
    backgroundColor: "#ffffff",
    startUrl: "/",
    display: "standalone",
    scope: "/",
    orientation: "any",
  },

  // SEO and crawling
  seo: {
    indexing: "allow",
    sitemapUrl: \`\${site_url}/sitemap.xml\`,
    disallowPaths: ["/admin", "/auth", "/login", "/register", "/chat", "/api", "/_next"],
    canonicalBase: site_url,
    locales: ["ru"],
    defaultLocale: "ru",
    social: {
      twitter: "@aifa_agi",
      github: "https://github.com/aifa-agi/aifa",
    },
  },

  // Open Graph / Twitter defaults
  og: {
    type: "website",
    locale: "ru_RU",
    siteName: "${config.short_name}",
    imageWidth: 1200,
    imageHeight: 630,
  },

  // Per-page defaults (can be overridden by constructMetadata arguments)
  pageDefaults: {
    titleTemplate: "%s | ${config.short_name}",
    robotsIndex: true,
    robotsFollow: true,
  },

  messages: {
    loading: {
      title: "Loading...",
      subtitle: "Please wait",
    },
  },
};

// ============================================
// TYPE DEFINITIONS
// ============================================

export type SupportedLang = "ru" | "en" | "es" | "fr" | "de" | "it";

export type ImageFormat = "png" | "jpg" | "jpeg" | "webp" | "avif" | "svg" | "gif";

export type RegularImageType = 
  | "ogImage" 
  | "loading-dark" 
  | "loading-light"
  | "notFound-dark"
  | "notFound-light"
  | "error500-dark"
  | "error500-light"
  | "homePage-dark"
  | "homePage-light"
  | "chatbot-dark"
  | "chatbot-light";

/**
 * Comments in English: All image types including logo (for type checking)
 */
export type AllImageTypes = RegularImageType | "logo";

/**
 * Comments in English: Metadata stored for each uploaded image
 */
export interface ImageMetadata {
  /** Full path with extension: "/app-config-images/og-image.jpg" */
  path: string;
  /** File format/extension without dot: "jpg", "png", "svg" */
  format: ImageFormat;
  /** ISO 8601 timestamp of last upload */
  uploadedAt: string;
  /** Optional: File size in bytes */
  size?: number;
  /** Optional: Image dimensions in pixels */
  dimensions?: {
    width: number;
    height: number;
  };
}

/**
 * Comments in English: Main application configuration interface
 */
export interface AppConfig {
  name: string;
  short_name: string;
  description: string;
  url: string;
  manifest: string;
  mailSupport: string;
  lang: SupportedLang;
  chatBrand: string;

  // ‚úÖ Dynamic images with metadata (excluding logo)
  images: Record<RegularImageType, ImageMetadata>;

  // Logo field - NOT part of images, handled separately
  logo: string;

  icons: {
    faviconAny?: string;
    icon32?: string;
    icon48?: string;
    icon192: string;
    icon512: string;
    appleTouch?: string;
  };

  pwa: {
    themeColor: string;
    backgroundColor: string;
    startUrl: string;
    display: "fullscreen" | "standalone" | "minimal-ui" | "browser";
    scope?: string;
    orientation?: "any" | "portrait" | "landscape";
  };

  seo: {
    indexing: "allow" | "disallow";
    sitemapUrl?: string;
    disallowPaths?: string[];
    canonicalBase?: string;
    locales?: string[];
    defaultLocale?: string;
    social?: {
      twitter?: string;
      github?: string;
      linkedin?: string;
      facebook?: string;
    };
  };

  og?: {
    type?: "website" | "article" | "profile" | "video.other";
    locale?: string;
    siteName?: string;
    imageWidth?: number;
    imageHeight?: number;
  };

  pageDefaults?: {
    titleTemplate?: string;
    robotsIndex?: boolean;
    robotsFollow?: boolean;
  };

  messages?: {
    loading?: {
      title?: string;
      subtitle?: string;
    };
  };
}

// ============================================
// HELPER FUNCTIONS
// ============================================

/**
 * Comments in English: Get image path for regular (non-logo) images
 * Returns path from images metadata with proper extension
 * 
 * @param imageType - Type of regular image (e.g., "ogImage", "loading-dark")
 * @returns Full path to image file (e.g., "/app-config-images/og-image.jpg")
 * 
 * @example
 * const path = getImagePath("error500-dark");
 * // Returns: "/app-config-images/error500-dark.svg" or "/app-config-images/error500-dark.png"
 */
export function getImagePath(imageType: RegularImageType): string {
  const metadata = appConfig.images[imageType];
  if (!metadata?.path) {
    console.error(\`[appConfig] Image metadata not found for type: \${imageType}\`);
    // Fallback to default path with .svg extension
    return \`/app-config-images/\${imageType}.svg\`;
  }
  return metadata.path;
}

/**
 * Comments in English: Get image format/extension without dot
 * 
 * @param imageType - Type of regular image
 * @returns File format (e.g., "png", "svg", "jpg")
 */
export function getImageFormat(imageType: RegularImageType): ImageFormat {
  const metadata = appConfig.images[imageType];
  if (!metadata?.format) {
    console.warn(\`[appConfig] Format not found for \${imageType}, defaulting to svg\`);
    return "svg";
  }
  return metadata.format;
}

/**
 * Comments in English: Get logo path
 * Logo is NOT part of images - handled by separate upload flow
 * 
 * @returns Logo file path
 */
export function getLogoPath(): string {
  return appConfig.logo;
}

/**
 * Comments in English: Get OG image path (from images metadata)
 * 
 * @returns OG image path for social media sharing
 */
export function getOgImagePath(): string {
  return getImagePath("ogImage");
}

/**
 * Comments in English: Get loading illustration by theme
 * 
 * @param theme - "dark" or "light" theme
 * @returns Path to loading illustration
 * 
 * @example
 * const darkLoading = getLoadingIllustration("dark");
 * // Returns: "/app-config-images/loading-dark.svg" (or .png if uploaded as PNG)
 */
export function getLoadingIllustration(theme: "dark" | "light"): string {
  const imageType: RegularImageType = theme === "dark" ? "loading-dark" : "loading-light";
  return getImagePath(imageType);
}

/**
 * Comments in English: Get start chat illustration (uses logo)
 * 
 * @returns Path to start chat illustration (same as logo)
 */
export function getStartChatIllustration(): string {
  return appConfig.logo;
}

/**
 * Comments in English: Get error page illustration by type and theme
 * 
 * @param errorType - "404" or "500"
 * @param theme - "dark" or "light"
 * @returns Path to error page illustration
 * 
 * @example
 * const error404Dark = getErrorIllustration("404", "dark");
 * // Returns: "/app-config-images/not-found-dark.svg"
 */
export function getErrorIllustration(
  errorType: "404" | "500", 
  theme: "dark" | "light"
): string {
  let imageType: RegularImageType;
  
  if (errorType === "404") {
    imageType = theme === "dark" ? "notFound-dark" : "notFound-light";
  } else {
    imageType = theme === "dark" ? "error500-dark" : "error500-light";
  }
  
  return getImagePath(imageType);
}

/**
 * Comments in English: Get home page illustration by theme
 * 
 * @param theme - "dark" or "light"
 * @returns Path to home page illustration
 */
export function getHomePageIllustration(theme: "dark" | "light"): string {
  const imageType: RegularImageType = theme === "dark" ? "homePage-dark" : "homePage-light";
  return getImagePath(imageType);
}

/**
 * Comments in English: Get chatbot illustration by theme
 * 
 * @param theme - "dark" or "light"
 * @returns Path to chatbot illustration
 */
export function getChatbotIllustration(theme: "dark" | "light"): string {
  const imageType: RegularImageType = theme === "dark" ? "chatbot-dark" : "chatbot-light";
  return getImagePath(imageType);
}

/**
 * Comments in English: Get full image metadata object
 * 
 * @param imageType - Type of regular image
 * @returns Complete metadata object or null if not found
 */
export function getImageMetadata(imageType: RegularImageType): ImageMetadata | null {
  return appConfig.images[imageType] || null;
}

/**
 * Comments in English: Check if image has metadata (was uploaded via admin panel)
 * 
 * @param imageType - Type of regular image
 * @returns true if metadata exists with valid path
 */
export function hasImageMetadata(imageType: RegularImageType): boolean {
  return !!appConfig.images[imageType]?.path;
}

/**
 * Comments in English: Get all image types that have been uploaded
 * 
 * @returns Array of image types with valid metadata
 */
export function getUploadedImageTypes(): RegularImageType[] {
  return (Object.keys(appConfig.images) as RegularImageType[]).filter(
    (key) => appConfig.images[key]?.path
  );
}

/**
 * Comments in English: Get image upload timestamp
 * 
 * @param imageType - Type of regular image
 * @returns ISO 8601 timestamp string or null
 */
export function getImageUploadDate(imageType: RegularImageType): string | null {
  return appConfig.images[imageType]?.uploadedAt || null;
}

// Last updated: ${timestamp}
// Generated by: app-config-persist-api
`;
}

async function saveToGitHub(
  config: AppConfigUpdateData
): Promise<AppConfigPersistResponse> {
  try {
    const { isValid, missingVars } = validateGitHubConfig();
    if (!isValid) {
      return {
        status: AppConfigOperationStatus.GITHUB_API_ERROR,
        message: `Missing GitHub configuration: ${missingVars.join(", ")}`,
        error: `Missing environment variables: ${missingVars.join(", ")}`,
        errorCode: AppConfigErrorCode.GITHUB_TOKEN_INVALID,
        environment: "production",
      };
    }

    const { GITHUB_TOKEN, GITHUB_REPO } = process.env;
    const fileContent = generateAppConfigFile(config);

    let currentFile: { content: string; sha: string } | null = null;

    try {
      currentFile = await getCurrentFileFromGitHub();
    } catch (error) {
      // File doesn't exist, will create new
    }

    if (currentFile && currentFile.content === fileContent) {
      return {
        status: AppConfigOperationStatus.SUCCESS,
        message: "GitHub file is already up to date",
        environment: "production",
      };
    }

    const apiPayload = {
      message: `Update AppConfig - ${new Date().toISOString()}`,
      content: Buffer.from(fileContent, "utf-8").toString("base64"),
      branch: process.env.GITHUB_BRANCH || "main",
      ...(currentFile && { sha: currentFile.sha }),
    };

    const response = await fetch(
      `https://api.github.com/repos/${GITHUB_REPO}/contents/${GITHUB_RELATIVE_PATH}`,
      {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${GITHUB_TOKEN}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
          "User-Agent": "NextJS-App",
        },
        body: JSON.stringify(apiPayload),
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return {
        status: AppConfigOperationStatus.GITHUB_API_ERROR,
        message: "Failed to update file on GitHub",
        error: `GitHub API returned ${response.status}: ${errorData.message || "Unknown error"}`,
        errorCode:
          response.status === 401
            ? AppConfigErrorCode.GITHUB_TOKEN_INVALID
            : AppConfigErrorCode.GITHUB_API_UNAVAILABLE,
        environment: "production",
      };
    }

    return {
      status: AppConfigOperationStatus.SUCCESS,
      message: "Successfully updated AppConfig on GitHub",
      environment: "production",
    };
  } catch (error: any) {
    return {
      status: AppConfigOperationStatus.GITHUB_API_ERROR,
      message: "Network error while connecting to GitHub",
      error: error.message || "Unknown network error",
      errorCode: AppConfigErrorCode.NETWORK_ERROR,
      environment: "production",
    };
  }
}

function saveToFileSystem(
  config: AppConfigUpdateData
): AppConfigPersistResponse {
  try {
    const fileContent = generateAppConfigFile(config);

    const dir = path.dirname(CONFIG_PATH);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    let hasChanged = true;
    if (fs.existsSync(CONFIG_PATH)) {
      const currentContent = fs.readFileSync(CONFIG_PATH, "utf-8");
      hasChanged = currentContent !== fileContent;
    }

    if (!hasChanged) {
      return {
        status: AppConfigOperationStatus.SUCCESS,
        message: "Local file is already up to date",
        environment: "development",
      };
    }

    fs.writeFileSync(CONFIG_PATH, fileContent, "utf-8");

    return {
      status: AppConfigOperationStatus.SUCCESS,
      message: "Successfully saved to filesystem",
      environment: "development",
    };
  } catch (error: any) {
    return {
      status: AppConfigOperationStatus.FILESYSTEM_ERROR,
      message: "Failed to save file to local filesystem",
      error: error.message || "Unknown filesystem error",
      errorCode: AppConfigErrorCode.FILE_WRITE_FAILED,
      environment: "development",
    };
  }
}

export async function POST(req: NextRequest) {
  const requestId = crypto.randomUUID();

  console.log(`\n${"=".repeat(70)}`);
  console.log(`[${requestId}] üöÄ NEW REQUEST: AppConfig Persist API`);
  console.log(`${"=".repeat(70)}`);

  // üîê AUTHORIZATION CHECK: Only privileged users can persist AppConfig
  const authResult = await requirePrivilegedUser(
    requestId,
    "Only administrators, architects, and editors can update application configuration"
  );

  if (!authResult.success) {
    console.log(`${"=".repeat(70)}\n`);
    return authResult.response;
  }

  const { session, userRole, isPrivileged } = authResult;

  console.log(`[${requestId}] ‚úÖ User authorized: ${session?.user?.email || "unknown"}`);
  console.log(`[${requestId}] ‚úÖ User role: ${userRole}`);
  console.log(`[${requestId}] ‚úÖ Proceeding with AppConfig persist operation...`);

  try {
    const body = await req.json();
    const config = body as AppConfigUpdateData;

    console.log(`[${requestId}] üìù Received config data:`, {
      name: config.name,
      short_name: config.short_name,
      lang: config.lang,
    });

    // Validate required fields
    const requiredFields: (keyof AppConfigUpdateData)[] = [
      "name",
      "short_name",
      "description",
      "lang",
      "logo",
      "chatBrand",
      "siteUrl",
    ];

    const missingFields = requiredFields.filter((field) => !config[field]);

    if (missingFields.length > 0) {
      console.error(`[${requestId}] ‚ùå Validation failed: Missing fields - ${missingFields.join(", ")}`);
      
      const validationResponse: AppConfigPersistResponse = {
        status: AppConfigOperationStatus.VALIDATION_ERROR,
        message: "Invalid data format",
        error: `Missing required fields: ${missingFields.join(", ")}`,
        errorCode: AppConfigErrorCode.INVALID_DATA_FORMAT,
        environment: isProduction() ? "production" : "development",
      };
      
      console.log(`${"=".repeat(70)}\n`);
      return NextResponse.json(validationResponse, { status: 400 });
    }

    console.log(`[${requestId}] ‚úÖ Validation passed`);
    console.log(`[${requestId}] üíæ Saving to filesystem...`);

    const localResult = saveToFileSystem(config);

    console.log(`[${requestId}] üíæ Filesystem result: ${localResult.status}`);

    if (isProduction()) {
      console.log(`[${requestId}] üåê Production mode: Syncing to GitHub...`);
      
      const githubResult = await saveToGitHub(config);

      console.log(`[${requestId}] üåê GitHub result: ${githubResult.status}`);

      if (
        localResult.status === AppConfigOperationStatus.SUCCESS &&
        githubResult.status !== AppConfigOperationStatus.SUCCESS
      ) {
        console.warn(`[${requestId}] ‚ö†Ô∏è  Partial success: Saved locally but GitHub sync failed`);
        console.log(`${"=".repeat(70)}\n`);
        
        return NextResponse.json({
          status: AppConfigOperationStatus.SUCCESS,
          message: "Saved locally but GitHub sync failed",
          error: githubResult.error,
          environment: "production",
        });
      }

      const httpStatus =
        githubResult.status === AppConfigOperationStatus.SUCCESS ? 200 : 500;
      
      console.log(`[${requestId}] üéØ Final status: ${githubResult.status} (HTTP ${httpStatus})`);
      console.log(`${"=".repeat(70)}\n`);
      
      return NextResponse.json(githubResult, { status: httpStatus });
    }

    const httpStatus =
      localResult.status === AppConfigOperationStatus.SUCCESS ? 200 : 500;
    
    console.log(`[${requestId}] üéØ Final status: ${localResult.status} (HTTP ${httpStatus})`);
    console.log(`${"=".repeat(70)}\n`);
    
    return NextResponse.json(localResult, { status: httpStatus });
  } catch (error: any) {
    console.error(`[${requestId}] üí• Unexpected error:`, error);
    console.log(`${"=".repeat(70)}\n`);
    
    const errorResponse: AppConfigPersistResponse = {
      status: AppConfigOperationStatus.UNKNOWN_ERROR,
      message: "An unexpected error occurred",
      error: error.message || "Unknown error",
      environment: isProduction() ? "production" : "development",
    };

    return NextResponse.json(errorResponse, { status: 500 });
  }
}

export async function GET() {
  try {
    return NextResponse.json({
      status: "ok",
      message: "AppConfig persist API endpoint",
      environment: isProduction() ? "production" : "development",
    });
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message || "Unknown error" },
      { status: 500 }
    );
  }
}
